@using WordSearch.Domain.ValueObjects
@using static WordSearch.Web.Pages.Index

<div class="grid-container">
    @if (Letters == null)
    {
        <div class="grid-placeholder">
            <p>Upload a word search puzzle to begin</p>
        </div>
    }
    else
    {
        <div class="grid-wrapper">
            <div class="letter-grid" style="grid-template-columns: repeat(@GetCols(), 1fr);">
                @for (var row = 0; row < GetRows(); row++)
                {
                    @for (var col = 0; col < GetCols(); col++)
                    {
                        var r = row;
                        var c = col;
                        var highlightColor = GetHighlightColor(r, c);
                        var isElevated = IsCellElevated(r, c);
                        <div class="grid-cell @(highlightColor != null ? "highlighted" : "") @(isElevated ? "elevated" : "")"
                             style="@(highlightColor != null ? $"background-color: {highlightColor};" : "")">
                            @Letters[r, c]
                        </div>
                    }
                }
            </div>

            @if (ShowCircles && Circles.Count > 0)
            {
                <svg class="circle-overlay" width="@(GetCols() * CellSize)" height="@(GetRows() * CellSize)">
                    @foreach (var circle in Circles)
                    {
                        var isHovered = circle.Answer == _hoveredCircle;
                        var path = GetStadiumPath(circle);
                        <path
                            d="@path"
                            stroke="@circle.Color"
                            stroke-width="@(isHovered ? 5 : 3)"
                            fill="@circle.Color"
                            fill-opacity="@(isHovered ? 0.3 : 0)"
                            style="@(isHovered ? "filter: drop-shadow(0 0 2px rgba(0,0,0,0.3));" : "")"
                            class="answer-circle @(isHovered ? "hovered" : "")"
                            @onmouseenter="() => HandleCircleEnter(circle.Answer)"
                            @onmouseleave="HandleCircleLeave" />
                    }
                </svg>
            }
        </div>
    }
</div>

@code {
    private const double CellSize = 40;

    [Parameter] public char[,]? Letters { get; set; }
    [Parameter] public List<HighlightedCell> HighlightedCells { get; set; } = new();
    [Parameter] public List<CircleData> Circles { get; set; } = new();
    [Parameter] public bool ShowCircles { get; set; }
    [Parameter] public EventCallback<string?> OnCircleHover { get; set; }

    private string? _hoveredCircle;

    private int GetRows() => Letters?.GetLength(0) ?? 0;
    private int GetCols() => Letters?.GetLength(1) ?? 0;

    private string? GetHighlightColor(int row, int col)
    {
        var cell = HighlightedCells.FirstOrDefault(c => c.Row == row && c.Col == col);
        return cell?.Color;
    }

    private bool IsCellElevated(int row, int col)
    {
        if (_hoveredCircle == null) return false;

        var circle = Circles.FirstOrDefault(c => c.Answer == _hoveredCircle);
        if (circle == null) return false;

        // Calculate all cells along the line from start to end
        var startRow = circle.Start.Row;
        var startCol = circle.Start.Col;
        var endRow = circle.End.Row;
        var endCol = circle.End.Col;

        var rowStep = endRow == startRow ? 0 : (endRow > startRow ? 1 : -1);
        var colStep = endCol == startCol ? 0 : (endCol > startCol ? 1 : -1);

        var r = startRow;
        var c = startCol;

        while (true)
        {
            if (r == row && c == col) return true;
            if (r == endRow && c == endCol) break;
            r += rowStep;
            c += colStep;
        }

        return false;
    }

    private string GetStadiumPath(CircleData circle)
    {
        // Get center points of start and end cells
        var startX = (circle.Start.Col + 0.5) * CellSize;
        var startY = (circle.Start.Row + 0.5) * CellSize;
        var endX = (circle.End.Col + 0.5) * CellSize;
        var endY = (circle.End.Row + 0.5) * CellSize;

        // Calculate the angle of the word
        var dx = endX - startX;
        var dy = endY - startY;
        var angle = Math.Atan2(dy, dx);

        // Radius for the semicircle ends (half cell height with padding) - tighter like Vue app
        var r = CellSize * 0.38;

        // Perpendicular offset for the parallel lines
        var perpX = Math.Sin(angle) * r;
        var perpY = -Math.Cos(angle) * r;

        // Extend start and end points outward by a small amount for padding
        var padding = CellSize * 0.05;
        var extendX = Math.Cos(angle) * padding;
        var extendY = Math.Sin(angle) * padding;

        var sx = startX - extendX;
        var sy = startY - extendY;
        var ex = endX + extendX;
        var ey = endY + extendY;

        // Four corners of the stadium (two parallel lines)
        var topStartX = sx + perpX;
        var topStartY = sy + perpY;
        var topEndX = ex + perpX;
        var topEndY = ey + perpY;
        var bottomEndX = ex - perpX;
        var bottomEndY = ey - perpY;
        var bottomStartX = sx - perpX;
        var bottomStartY = sy - perpY;

        // Build the path using invariant culture for decimal formatting
        return string.Create(System.Globalization.CultureInfo.InvariantCulture,
            $"M {topStartX} {topStartY} L {topEndX} {topEndY} A {r} {r} 0 0 1 {bottomEndX} {bottomEndY} L {bottomStartX} {bottomStartY} A {r} {r} 0 0 1 {topStartX} {topStartY} Z");
    }

    private async Task HandleCircleEnter(string answer)
    {
        _hoveredCircle = answer;
        await OnCircleHover.InvokeAsync(answer);
    }

    private async Task HandleCircleLeave()
    {
        _hoveredCircle = null;
        await OnCircleHover.InvokeAsync(null);
    }
}
